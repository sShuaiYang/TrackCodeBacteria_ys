function [regionAngle,bwImage,isTriadius,openNum]=findJunctionPieces(bwImage,varargin)
BW2=bwmorph(bwImage,'thin',inf);
bwImage1=imopen(bwImage,ones(5));
cc1=bwconncomp(bwImage1);
bwImage2=imopen(bwImage,ones(2));
cc2=bwconncomp(bwImage2);
bwImage3=imopen(bwImage,strel('diamond',2));
cc3=bwconncomp(bwImage3);
bwImage4=imopen(bwImage,strel('diamond',1));
cc4=bwconncomp(bwImage4);
compNum=[cc1.NumObjects;cc2.NumObjects;cc3.NumObjects;cc4.NumObjects];
if cc2.NumObjects==max(compNum)
    bwImage=bwImage2;
else if cc4.NumObjects==max(compNum)
        bwImage=bwImage4;
    else if cc1.NumObjects==max(compNum)
            bwImage=bwImage1;
        else if cc3.NumObjects==max(compNum)
                bwImage=bwImage3;
            end
        end
    end
end                          %%use open to recognize the link position, se could change depend on its effect
openNum=max(compNum);
BW=bwmorph(bwImage,'skel',inf);
% BW4 = bwmorph(BW3,'spur',10);  % 10=delete noise branchs Inf=Extract Main branch
BWs=bwmorph(BW2,'spur',1);
[row,col]=size(BW);
j_xy2=anaskel_3(row,col,BWs);
if j_xy2==0
    isTriadius=0;
else
    isTriadius=1;
end
j_xy=anaskel_3(row,col,BW);
if j_xy~=0
    len=size(j_xy,2);
    BW3=false(size(BW));
    for i=1:len % 'len' is count of junction
        BW3(j_xy(2,i),j_xy(1,i))=1;
    end
    if j_xy2==0
        seForPoint=true(3);
    else
        seForPoint=true(5);
    end
    BW3=imdilate(BW3,seForPoint);
    BW2(BW3==1)=0;
end
% BW2=bwareaopen(BW2,threShold);
regionAngle=regionprops(BW2,varargin);
end
function jxy=anaskel_3(nrow,ncol,InputImage)

% this array is 256 length.
nbrs = [ ...
    0,1,1,1,1,1,1,1,...
    1,2,2,2,1,1,1,1,...
    1,2,2,2,1,1,1,1,...
    1,2,2,2,1,1,1,1,...
    1,2,2,2,2,2,2,2,...
    2,3,3,3,2,2,2,2,...
    1,2,2,2,1,1,1,1,...
    1,2,2,2,1,1,1,1,...
    1,1,2,1,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    2,2,3,2,3,2,3,2,...
    3,3,4,3,3,2,3,2,...
    2,2,3,2,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    1,1,2,1,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,2,1,2,1,...
    2,2,3,2,2,1,2,1,...
    1,1,2,1,1,1,1,1,...
    1,1,2,1,1,1,1,1 ...
    ];

nbr_branches = [...
    0,1,1,1,1,2,1,2,...
    1,2,2,2,1,2,2,2,...
    1,2,2,2,2,3,2,3,...
    1,2,2,2,2,3,2,3,...
    1,2,2,2,2,3,2,3,...
    2,3,3,3,2,3,3,3,...
    1,2,2,2,2,3,2,3,...
    2,3,3,3,2,3,3,3,...
    1,2,2,2,2,3,2,3,...
    2,3,3,3,2,3,3,3,...
    2,3,3,3,3,4,3,4,...
    2,3,3,3,3,4,3,4,...
    1,2,2,2,2,3,2,3,...
    2,3,3,3,2,3,3,3,...
    2,3,3,3,3,4,3,4,...
    2,3,3,3,3,4,3,4,...
    1,1,2,2,2,2,2,2,...
    2,2,3,3,2,2,3,3,...
    2,2,3,3,3,3,3,3,...
    2,2,3,3,3,3,3,3,...
    2,2,3,3,3,3,3,3,...
    3,3,4,4,3,3,4,4,...
    2,2,3,3,3,3,3,3,...
    3,3,4,4,3,3,4,4,...
    1,2,2,2,2,3,2,3,...
    2,3,3,3,2,3,3,3,...
    2,3,3,3,3,4,3,4,...
    2,3,3,3,3,4,3,4,...
    2,2,3,3,3,3,3,3,...
    3,3,4,4,3,3,4,4,...
    2,3,3,3,3,4,3,4,...
    3,3,4,4,3,4,4,4,...
    ];
skel = zeros(1,nrow*ncol);
skel=dotrim(InputImage,nrow,ncol,skel,nbrs,nbr_branches);
for j = 1: ncol-1
    for i = 0:nrow
        p = i+j*nrow;
        if skel(p)
            hood = neighborhood(skel,i,j,nrow,ncol);
        end
    end
end
% the jxy are junctions. let's make it a 2D array unlike the c++ program.
jxy = 0;
ijunc = 0;
for j=1: ncol-1
    for i = 1: nrow
        if skel(i+j*nrow)
            hood = neighborhood(skel,i,j,nrow,ncol);
            if nbr_branches(hood) > 2
                jxy(1,ijunc+1) = j+1;
                jxy(2,ijunc+1) = i+1;
                ijunc =ijunc+ 1;
            end% end if
        end %end if;
    end %end for
end %end for
end
function skel=dotrim(inp, nrow, ncol,skel,connected_nbrs,nbr_branches)
for j = 1:  ncol-1
    for i = 1: nrow
        skel(i+j*nrow) = (inp(i+j*nrow));
    end
end
for j = 1:ncol-1
    for i = 1: nrow
        if skel(i+j*nrow)
            hood = neighborhood(skel,i,j,nrow,ncol);
            skel(i+j*nrow) = (connected_nbrs(hood) > 1)|(nbr_branches(hood)==1);
        else
            skel(i+j*nrow) = 0;
        end
    end % end for
end% end for
end
function NeighborOut=neighborhood(arr,i, j,  nrow,  ncol)
p = i+j*nrow;
condition = 8*(i <= 1)+4*(j <= 1)+2*(i >= nrow-1)+(j >= ncol-1);
NeighborOut=0;
%   //mexPrintf("Condition:  %d\n",condition);
switch (condition)
    case 0,  %// all sides valid
        if (p-nrow-1)<1 || (p+nrow+1)>nrow*ncol,
            % too low or too high
            NeighborOut=0;
        else
            NeighborOut= arr(p-1) + 2*arr(p+nrow-1) + 4*arr(p+nrow) +...
                8*arr(p+nrow+1)+ 16*arr(p+1) + 32*arr(p-nrow+1) +...
                64*arr(p-nrow) + 128*arr(p-nrow-1);
        end;
    case 1,  %// right side not valid
        NeighborOut= arr(p-1) + 16*arr(p+1) + 32*arr(p-nrow+1) +...
            64*arr(p-nrow) + 128*arr(p-nrow-1);
    case 2, % // bottom not valid
        NeighborOut =arr(p-1) + 2*arr(p+nrow-1) + 4*arr(p+nrow) +...
            64*arr(p-nrow) + 128*arr(p-nrow-1);
    case 3, % // bottom and right not valid
        NeighborOut= arr(p-1) + 64*arr(p-nrow) + 128*arr(p-nrow-1);
    case 4, % // left side not valid
        NeighborOut= arr(p-1) + 2*arr(p+nrow-1) + 4*arr(p+nrow) +...
            8*arr(p+nrow+1) + 16*arr(p+1);
    case 5, %// left and right sides not valid
        NeighborOut= arr(p-1) + 16*arr(p+1);
    case 6,  %// left and bottom sides not valid
        NeighborOut= arr(p-1) + 2*arr(p+nrow-1) + 4*arr(p+nrow);
    case 7,  % left, bottom, and right sides not valid
        NeighborOut= arr(p-1);
    case 8, % top side not valid
        NeighborOut= 4* arr(p+nrow) + 8*arr(p+nrow+1) + 16*arr(p+1) +...
            32*arr(p-nrow+1) + 64*arr(p-nrow);
    case 9,  % top and right not valid
        NeighborOut= 16*arr(p+1) + 32*arr(p-nrow+1) + 64*arr(p-nrow);
    case 10,  % top and bottom not valid
        NeighborOut= 4*arr(p+nrow) + 64*arr(p-nrow);
    case 11,  % top, bottom and right not valid
        NeighborOut= 64*arr(p-nrow);
    case 12,  % top and left not valid
        NeighborOut= 4*arr(p+nrow) + 8*arr(p+nrow+1) + 16*arr(p+1);
    case 13,  % top, left and right sides not valid
        NeighborOut= 16*arr(p+1);
    case 14,  % top, left and bottom sides not valid
        NeighborOut= 4*arr(p+nrow);
    case 15,  % no sides valid
        NeighborOut= 0;
end; % end switch condition
NeighborOut=NeighborOut+1; % because in Matlab, indices start at 1 not 0
end